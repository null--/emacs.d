/**
 * @file
 *
 * @author  Sina Hatef Matbue ( _null_ ) <sinahatef.cpp@gmail.com>
 *
 * @section License
 *
 * This file is part of GraVitoN.
 *
 * Graviton is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Graviton is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Graviton.  If not, see http://www.gnu.org/licenses/.
 *
 * @brief GraVitoN::Core::UDP_Client
 *
 */

#ifndef GRAVITON_UDP_CLIENT_H
#define GRAVITON_UDP_CLIENT_H

#include <graviton.hpp>
#include <core/memory.hpp>
#include <core/logger.hpp>
#include <core/socket.hpp>

namespace GraVitoN
{

    namespace Core
    {

        class UDP_Client
        {
        protected:
            /// Socket
            Socket::Handle sock;
            Socket::Address sa;
            guint local_port;
            string local_ip;
            
            /// recv packet
            virtual bool doRecv(unsigned char *&data, size_t &data_size, ting::net::IPAddress &sender_addr);

        public:
            /// Constructor
            UDP_Client();
            
            virtual ~UDP_Client();

            virtual bool open();

            virtual bool close();

            template<class Type>
            virtual bool recv(Memory<Type> &data);

            /// Like recv but also stored ip address and port number of sender
            template<class Type>
            virtual bool recv(Memory<Type> &data, string &_sender_ip, guint &_sender_port);

            // virtual string recvString(string &_sender_ip, unsigned int &_sender_port)
            template<class Type>
            virtual string recvString();

            /// Send data to client
            template<class Type>
            virtual bool send(const Memory<Type> &data, const string &ip, const guint &port);

            /// send string
            virtual bool sendString(const string &data, const string &ip, const guint &port);
            
            virtual bool isActive();
        };

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-//
        UDP_Client::UDP_Client(const string &local_ip_, const guint &listen_port_)
        {
            Socket::getInstance();

            local_port = local_port_;
            local_ip = local_ip_;
            
            // open();
        }

        UDP_Client::~UDP_Client()
        {
            if( sock.IsValid() )
                UDP_Client::close();
        }

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-//
        bool UDP_Client::open()
        {
            try
            {
                UDP_Client::close();
                
                sock = socket(AF_INET, SOCK_DGRAM, 0);

                if( Socket::invalidSocket( sock ) )
                {
                    Logger::logItLn("[UDP_Client] socket creation failed");
                    return false;
                }

                if( local_port == 0 )
                {
                    sa.sin_family      = AF_INET;
                    /// server IP
                    sa.sin_addr.s_addr = ;
                    /// Server Port
                    sa.sin_port        = htons     (listen_port);
                
                    return false;
                }
                
                sa.sin_family      = AF_INET;
                /// server IP
                sa.sin_addr.s_addr = inet_addr (ip.c_str());
                /// Server Port
                sa.sin_port        = htons     (listen_port);
                
                if( Socket::socketError( bind(sa, &sa, sizeof(sa)) ) )
                {
                    Logger::logItLn("[UDP_Client] bind failed");
                    return false;
                }
            }
            catch(ting::net::Exc &e)
            {
                Logger::logVariable("Network error", e.What());
                return false;
            }
            return true;
        }

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-//
        bool UDP_Client::close()
        {
            try
            {
                sock.Close();
            }
            catch(ting::net::Exc &e)
            {
                Logger::logVariable("Network error", e.What());
                return false;
            }
            return true;
        }

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-//
/*
  bool UDP_Client::run()
  {
  /// Open socket
  open();

  send((const unsigned char*)"Hello Server", 13);

  unsigned int size;
  unsigned char *data;
  recv(data, size);

  /// Close Socket
  close();

  return true;
  }
*/

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-//
        bool UDP_Client::send(const unsigned char *data, const size_t &data_size, const string &ip, const unsigned int &port)
        {
            try
            {
                ting::WaitSet waitSet(1);
                waitSet.Add(&sock, ting::Waitable::WRITE);
                // Logger::logItLn("[Recv UDP] Waiting...");
                waitSet.Wait();

                ting::Buffer<const unsigned char> data_buf(data, (size_t)data_size);
                ting::net::IPAddress m_addr(ip.c_str(), port);
                sock.Send(data_buf, m_addr);
            }
            catch(ting::net::Exc &e)
            {
                Logger::logVariable("Network error", e.What());
                return false;
            }

            return true;
        }

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-//
        bool UDP_Client::doRecv(unsigned char *&data, size_t &data_size, ting::net::IPAddress &sender_addr)
        {
            try
            {
                //if ( data )
                //delete data;

                ting::StaticBuffer<unsigned char, GraVitoN::Config::MAX_TCP_PACKET_SIZE> data_buf;
                size_t bytes_recved = 0;

                /*
                  while( bytes_recved == 0 )
                  {
                  bytes_recved = sock.Recv(data_buf, addr);
                  }
                */

                ting::WaitSet waitSet(1);
                waitSet.Add(&sock, ting::Waitable::READ);
                // Logger::logItLn("[Recv UDP] Waiting...");
                waitSet.Wait();

                bytes_recved = sock.Recv(data_buf, sender_addr);
                if( bytes_recved == 0 )
                    return false;
                //Logger::logVariable("Bytes Recved: ", bytes_recved);
                data_size = bytes_recved;
                data = new unsigned char[data_size + 1];

                for(size_t i=0; i<bytes_recved; ++i)
                    data[i] = data_buf[i];
                data[data_size] = '\0';
            }
            catch(ting::net::Exc &e)
            {
                Logger::logVariable("Network error", e.What());
                return false;
            }

            return true;
        }
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-//
        bool UDP_Client::recv(unsigned char *&data, size_t &data_size)
        {
            ting::net::IPAddress sender_addr;
            return doRecv(data, data_size, sender_addr);
        }

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-//
        bool UDP_Client::recv(unsigned char *&data, size_t &data_size, string &_sender_ip, unsigned int &_sender_port)
        {
            ting::net::IPAddress sender_addr;
            bool res = doRecv(data, data_size, sender_addr);

            if(res)
            {
                _sender_ip = Utils::Netkit::hexToStrIPv4(sender_addr.host);
                _sender_port = sender_addr.port;

                cout << _sender_ip << endl;
                cout << _sender_port << endl;

                return true;
            }
            return false;
        }

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-//
        bool UDP_Client::isActive()
        {
            return sock.IsValid();
        }

    } // Core

//=============================================================================//
#ifdef GVN_ACTIVATE_LUABRIDGE
    namespace LUABridge
    {

        void addClass_UDP_Client()
        {
            Core::Logger::logItLn("Loaing GraVitoN.Core.UDP_Client");

            luabridge::getGlobalNamespace ( Core::Luaviton::getInstance().getState() )
                .beginNamespace("GraVitoN")
                .beginNamespace("Core")
                .beginClass <Core::UDP_Client> ("UDP_Client")
                .addConstructor < void(*) (), RefCountedPtr<Core::UDP_Client> > ()
                .addConstructor < void(*) (const unsigned int&), RefCountedPtr<Core::UDP_Client> > ()
                // .addConstructor < void(*) (Core::TCP_Socket), RefCountedPtr<Core::UDP_Client> > ()
                .addFunction("open", &Core::UDP_Client::open)
                .addFunction("close", &Core::UDP_Client::close)
                .addFunction("sendString", &Core::UDP_Client::sendString)
                .addFunction("recvString", &Core::UDP_Client::recvString)
                .addFunction("isActive", &Core::UDP_Client::isActive)
                .endClass()
                .endNamespace()
                .endNamespace()
                ;
        }
    }
#endif

} // end of GraVitoN

#endif // GRAVITON_UDP_CLIENT
