/**
 * @file
 *
 * @author  Sina Hatef Matbue ( _null_ ) <sinahatef.cpp@gmail.com>
 *
 * @section License
 *
 * This file is part of GraVitoN.
 *
 * Graviton is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Graviton is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Graviton.  If not, see http://www.gnu.org/licenses/.
 *
 * @brief XML Parser
 *
 */

#ifndef _GVN_XMLPARSER_HEAD_
#define _GVN_XMLPARSER_HEAD_

#include <graviton.hpp>
#include <core/logger.hpp>

#include <external/rapidxml/rapidxml.hpp>
#include <external/rapidxml/rapidxml_utils.hpp>
#include <external/rapidxml/rapidxml_print.hpp>

namespace GraVitoN
{
    namespace Utils
    {
        /* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
        /// xml attribute
        class XML_Attrib
        {
		private:
			rapidxml::xml_attribute<> *attr;
			
        public:
            XML_Attrib(rapidxml::xml_attribute<> * _attr = _null_) { attr = _attr; }
			~XML_Attrib() {}

            /// cast XML_Attrib* to xml_attribute<>*
			operator rapidxml::xml_attribute<> * ()
                {
                    return attr;
                }

            /// check if attribute is valid
			bool operator ! ()
                {
                    return attr == _null_;
                }

            /** get next attribute
             * @params [IN]
             * name of attribute, use a empty string as argument when you want to retrive next-nearest attribute.
             */
            XML_Attrib   next(const std::string &name = "")
                {
                    if( !attr ) return XML_Attrib(_null_);
                    return (XML_Attrib)(name.full()?(attr->next_attribute(name.c_str())):(attr->next_attribute()));
                }

            /// get attribute name
            std::string name()					  
                {
                    if( !attr ) return _null_;
                    return std::string(attr->name());
                }

            /// set attribute name
			void setName(const std::string &name)    
                {
                    if( !attr ) return;
                    attr->name( name.c_str() );
                }

            /// get attribute value
			string value()		  
                {
                    if( !attr ) return _null_;
                    return std::string(attr->value()); 
                }

            /// set attribute value
            void setValue(const std::string &value)  
                {
                    if(!attr) return;
                    attr->value( value.c_str() );
                }
        };
        
        class XML_Node
        {
		private:
			rapidxml::xml_node<> *node;
			
        public:  
            XML_Node(rapidxml::xml_node<> *_node = _null_)
                {
                    node = _node;
                }
			
			~XML_Node() {}

            /// check if node is valid
			bool operator ! ()
                {
                    return node == _null_;
                }

            /// cast XML_Node* to rapidxml::xml_node<>*
			operator rapidxml::xml_node<> * ()
                {
                    return node;
                }

            /// remove an attribute from node
            void removeAttribute(XML_Attrib &_attr)
                {
                    if(!node) return;
                    node->remove_attribute((rapidxml::xml_attribute<> *)_attr);
                }

            /// remove all attributes of node
			void removeAllAttributes()
                {
                    if(!node) return;
                    node->remove_all_attributes();
                }

            /// remove a child from ndoe
			void removeChild(XML_Node &_node)
                {
                    if(!node) return;
                    node->remove_node( (rapidxml::xml_node<>*)_node );
                }

            /// remove all childs of node
			void removeAllChilds()
                {
                    if(!node) return;
                    node->remove_all_nodes();
                }

            /// get first child of node (with or whitout a given name)
            XML_Node     firstChild(const std::string name = "")
                {
                    if(!node) return XML_Node(_null_);
                    return XML_Node(name.full()?(node->first_node(name.c_str())):(node->first_node()));
                }

            /// get next sibling node
			XML_Node     next(const std::string &name = "")
                {
                    if(!node) return XML_Node(_null_);
                    return XML_Node(name.full()?(node->next_sibling(name.c_str())):(node->next_sibling()));
                }

            /// get first attribute of node
            XML_Attrib   firstAttribute(const std::string &name = "")
                {
                    if(!node) return XML_Attrib(_null_);
                    return XML_Attrib(name.full()?(node->first_attribute(name.c_str())):(node->first_attribute()));
                }

            /// get name of the node
            std::string name()
                {
                    if(!node) return _null_;
                    return std::string(node->name());
                }

            /// set name of the node
            void setName(const std::string &name)    
                {
                    if(!node) return;
                    node->name( name.c_str() );
                } 

            /// set value of the node
            void setValue(const std::string &value)  
                {
                    if(!node) return;
                    node->value( value.c_str() );
                }

            /// get value of the node
            std::string value()
                {
                    if(!node) return _null_;
                    return std::string( node->value() );
                }
        };
            
        /* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
        class XML_Document
        {
		private:
			std::vector<char> file_data;   // File data
			rapidxml::xml_document<> xml_doc;
			
        public:
            XML_Parser();
            ~XML_Parser();

            /// add standard xml declaraion to a xml document
            bool addDecleration(const std::string &version = "0.1", const std::string &encoding = "UTF-8");
            bool addNode(XML_Node &node, const char *name, const char *value = "");
            bool addAttribute(XML_Node &node, XML_Attrib &attr, const std::string &name, const std::string &value);
            bool addChild(XML_Node &node, XML_Node &child, const char*name, const std::string &value = "");

            bool save(const char *path);
            bool load(const char *path);
            bool parse(char *path);

            XML_Node firstNode(const char *name = _null_)
                {
                    return XML_Node( xml_doc.first_node( name ) );
                }

            void clear() {xml_doc.clear();}
            // XML_Node *cloneNode(const XML_Node *&node) {return xml_doc.clone_node(node); }

            void removeNode(XML_Node &node) {xml_doc.remove_node( (rapidxml::xml_node<>*)node );}
            void removeAllNodes() {xml_doc.remove_all_nodes();}
        };

        /* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
        XML_Parser::XML_Parser()
        {
            // xml_doc.set_allocator(malloc, free);
        }

        /* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
        XML_Parser::~XML_Parser()
        {
        }

        /* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
        bool XML_Parser::addDecleration(const std::string &version, const std::string &encoding)
        {
            rapidxml::xml_node<>* decl = xml_doc.allocate_node(rapidxml::node_declaration);
			if(!decl) return false;
            decl->append_attribute(xml_doc.allocate_attribute("version", version.c_str()));
            decl->append_attribute(xml_doc.allocate_attribute("encoding", encoding.c_str()));
            xml_doc.append_node(decl);  
			return true;
        }

        /* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
        bool XML_Parser::addNode(XML_Node &node, const std::string &name, const std::string &value)
        {
            node = XML_Node(xml_doc.clone_node(xml_doc.allocate_node(rapidxml::node_element, name.c_str(), value.c_str())));

            if(!node) return false;
            xml_doc.append_node( (rapidxml::xml_node<>*)node );
            return true;
        }

        /* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
        bool XML_Parser::addChild(XML_Node &node, XML_Node &child, const std::string &name, const std::string &value)
        {
            child = XML_Node(xml_doc.clone_node(xml_doc.allocate_node(rapidxml::node_element, name.c_str(), value.c_str())));

            if(!child) return false;
            ((rapidxml::xml_node<>*)node)->append_node((rapidxml::xml_node<>*)child);
            return true;
        }

        /* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
        bool XML_Parser::addAttribute(XML_Node &node, XML_Attrib &attr, const std::string &name, const std::string &value)
        {
            attr = XML_Attrib( xml_doc.allocate_attribute(name.c_str(), value.c_str()) );
            if(!attr) return false;
            ((rapidxml::xml_node<>*)node)->append_attribute((rapidxml::xml_attribute<>*)attr);
            return true;
        }

        /* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
        bool XML_Parser::save(const std::string &path)
        {
            ofstream ofile;
            ofile.open(path.c_str());
            ofile << xml_doc;
            ofile.close();
            return true;
        }

        /* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
		bool XML_Parser::parse(std::string &text)
        {
			try
			{
				xml_doc.parse<0>( &text.front() );
			}
			catch( ... )
			{
				return false;
			}
			return true;
		}
		
        /* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
        bool XML_Parser::load(const std::string &filename)
        {
			try
			{
				// Open stream
				basic_ifstream<char> stream(filename.c_str(), ios::binary);
				if (!stream)
					throw runtime_error(string("cannot open file ") + filename);
				stream.unsetf(ios::skipws);
				
				// Determine stream size
				stream.seekg(0, ios::end);
				size_t size = stream.tellg();
				stream.seekg(0);   
				
				// Load data and add terminating 0
				file_data.resize(size + 1);
				stream.read(&file_data.front(), static_cast<streamsize>(size));
				file_data[size] = 0;
				
				return parse( &file_data.front());
			}
			catch(...)
			{
			}
			
            return false;
        }
    }
}

#endif
